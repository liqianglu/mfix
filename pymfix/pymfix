#!/usr/bin/env python

import os, sys
sys.path.append(os.getcwd())

import json
import threading
import time
import traceback

from flask import Flask, render_template, request, redirect, url_for
path = os.path.dirname(os.path.realpath(__file__))
app = Flask(__name__, static_folder=path+'/static', template_folder=path+'/templates')

import mfix

requests = {}
responses = {}

mfix_stopped = True

# change any variable...
# mfix.run.time  = 1000
# mfix.run.tstop = mfix.run.tstop/2
# mfix.run.dt    = 10

# response = 'the pressure is %s \n tstop is %s' % (str(mfix.fldvar.p_g[:100]),mfix.run.tstop)

pymfix_running = True

def run_mfix():
    global mfix_stopped

    if (len(sys.argv) > 100):
        print("TOO MANY COMMAND LINE ARGUMENTS")
        return

    for arg in sys.argv[1:]:
        mfix.main.add_command_line_argument(arg)

    mfix.main.initialize()
    while pymfix_running:
        check_requests()

        if mfix_stopped or mfix.run.tstop <= mfix.run.time:
            time.sleep(0.1)
        else:
            do_step()

    mfix.main.finalize()

def do_step():
    mfix.step.time_step_init()

    while True:
        mfix.iterate.iterate_init()
        while (mfix.iterate.nit<mfix.iterate.max_nit and not (mfix.iterate.converged or mfix.iterate.diverged)):
            mfix.iterate.nit = mfix.iterate.nit + 1
            mfix.iterate.do_iteration()
            check_requests()

        if (mfix.iterate.converged):
            if (mfix.run.dt==mfix.param1.undefined and mfix.iterate.nit==1):
                continue
            mfix.iterate.log_converged()
        elif (mfix.iterate.diverged):
            mfix.iterate.log_diverged()
        else:
            mfix.iterate.post_iterate()

        if(not mfix.iterate.adjustdt()):
            break

    mfix.step.time_step_end()

def check_requests():
    if requests:
        # requests would only arrive at rank 0
        req_id,cmd_var_args = requests.popitem()
    else:
        # command is empty for rank>0
        req_id = None
        cmd_var_args = (None,None,None)

    json_cmd_var_args = json.dumps(cmd_var_args)

    # broadcast command from rank 0 to all ranks
    json_cmd_var_args = mfix.main.do_mpi_bcast(json_cmd_var_args)

    command, varname, args = json.loads(json_cmd_var_args.tostring())

    if command:
        handle(req_id,command,varname,args)

def handle(req_id,command,var,args):
    global mfix_stopped

    cmd = command.split(' ')[0].lower().strip()

    print("THE COMMAND IS %s" % cmd)

    # TODO: refactor with a Command class, instead of a big switch statement
    if cmd=='write_dbg_vt':
        responses[req_id] = 200,'Calling WRITE_DBG_VTU_AND_VTP_FILES\n'
        mfix.main.do_write_dbg_vtu_and_vtp_files()

    elif cmd=='backupres':
        responses[req_id] = 200,'BACKING UP RESOURCE FILES\n'
        mfix.main.do_backupres()

    elif cmd=='reinit':
        responses[req_id] = 200,'REINITIALIZING MFIX\n'
        mfix.main.do_reinit(args.get('filename',None))

    elif cmd=='exit':
        responses[req_id] = 200,'EXITING MFIX\n'
        global pymfix_running
        pymfix_running = False

    elif cmd=='abort':
        responses[req_id] = 200,'ABORTING MFIX\n'
        mfix.main.do_abort()

    elif cmd=='stop':
        responses[req_id] = 200,'STOPPING MFIX\n'
        mfix_stopped = True

    elif cmd=='start':
        responses[req_id] = 200,'STARTING MFIX\n'
        mfix_stopped = False

    elif cmd=='step':
        stepcount = int(args.get('stepcount',None))
        for _ in range(stepcount):
            do_step()
        responses[req_id] = 200,'DOING %s TIMESTEP(S)\n' % stepcount

    elif cmd=='get':

        ids = args.get('ids',None)

        # slow things down for development
        time.sleep(mfix.compar.mype)

        if var:
            if ids and len(ids.split(' ')) > 3:
                print("GOING TO GET IDS %s" % var)
                ii,jj,kk,i2,j2,k2 = command.split(' ')[3:9]
                for i in range(int(ii),int(i2)+1):
                    for j in range(int(jj),int(j2)+1):
                        for k in range(int(kk),int(k2)+1):
                            if is_on_mype_owns(i,j,k):
                                exec_string = ('%s[%d] = %s' % (var,funijk(i,j,k)))
                                print("GOING TO EXECUTE: %s" % exec_string)
                                exec(exec_string)
                                print("rank ",mfix.compar.mype," set value for",i,j,k,funijk(i,j,k))
                            else:
                                print("rank ",mfix.compar.mype,"does not own",i,j,k,funijk(i,j,k))
            else:
                print("GOING TO EVALUATE %s" % var)
                try:
                    val = str(eval(var))
                    responses[req_id] = 200,val
                except:
                    traceback.print_exc()
                    # TODO: use error code for REST call
                    val = "ERROR: could not evaluate "+var
                    responses[req_id] = 400,val

                print("GOING TO RETURN %s" % val)

    elif cmd=='set':

        val = args.get('varvalue',None)
        ids = args.get('ids',None)

        # slow things down for development
        time.sleep(mfix.compar.mype)

        if var and val:
            if ids and len(ids.split(' ')) > 3:
                print("GOING TO SET IDS %s = %s" % (var,val))
                ii,jj,kk,i2,j2,k2 = command.split(' ')[3:9]
                for i in range(int(ii),int(i2)+1):
                    for j in range(int(jj),int(j2)+1):
                        for k in range(int(kk),int(k2)+1):
                            if is_on_mype_owns(i,j,k):
                                exec_string = ('%s[%d] = %s' % (var,funijk(i,j,k),val))
                                print("GOING TO EXECUTE: %s" % exec_string)
                                exec(exec_string)
                                print("rank ",mfix.compar.mype," set value for",i,j,k,funijk(i,j,k))
                            else:
                                print("rank ",mfix.compar.mype,"does not own",i,j,k,funijk(i,j,k))
            else:
                print("GOING TO SET %s = %s" % (var,val))
                try:
                    exec('%s = %s' % (var,val))
                    responses[req_id] = 200,'ok, I set %s to %s\n' % (var,val)
                except AttributeError:
                    # TODO: better error code REST response
                    responses[req_id] = 500,'ERROR could not set: %s to %s\n' % (var,val)

                print('ok, I set %s to %s\n' % (var,val))
        else:
            responses[req_id] = 500,'could not set %s to %s\n' % (var,val)
    else:
        responses[req_id] = 500,'UNRECOGNIZED COMMAND\n'

def funijk(i,j,k):
    return mfix.compar.ijk_array_of[i,j,k]

def is_on_mype_owns(li, lj, lk):
      return li >= mfix.compar.istart and li <= mfix.compar.iend and lj >= mfix.compar.jstart and lj <= mfix.compar.jend and lk >= mfix.compar.kstart and lk <= mfix.compar.kend


# Route that will process the file upload
@app.route('/upload', methods=['POST'])
def upload():
    # Get the name of the uploaded file
    ff = request.files['file']
    if ff:
        # filename = ff.filename
        filename = 'mfix.dat.upload'
        ff.save(os.path.join(os.getcwd(), filename))
    else:
        filename = None
        data = None

    status_code, data = do_command( "REINIT", args={'filename':filename} )

    return redirect(url_for('index',
                            filename=filename))

@app.route('/')
def index():
    return render_template('index.html', mfixdat_filename = request.args.get('filename',''))

@app.route('/set/<varname>',methods=['POST'])
def set(varname):
    status_code, data = do_command( "SET", varname, args=request.form )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/get/<varname>',methods=['GET'])
def get(varname):
    status_code, data = do_command( "GET", varname, args=request.args )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/write_dbg_vt',methods=['POST'])
def write_dbg_vt():
    status_code, data = do_command( "WRITE_DBG_VT" )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/backupres',methods=['POST'])
def backupres():
    status_code, data = do_command( "BACKUPRES" )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/exit',methods=['POST'])
def exit():
    status_code, data = do_command( "EXIT" )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/abort',methods=['POST'])
def abort():
    status_code, data = do_command( "ABORT" )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/step',methods=['POST'])
def step():
    status_code, data = do_command( "STEP", args=request.form )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/start',methods=['PUT'])
def start():
    status_code, data = do_command( "START" )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/stop',methods=['PUT'])
def stop():
    status_code, data = do_command( "STOP" )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

def do_command(cmd, varname=None, args = []):
    req_id = threading.current_thread().ident
    requests[req_id] = ( cmd, varname, args )
    while req_id not in responses:
        time.sleep(0.1)
    resp = responses[req_id]
    del responses[req_id]

    return resp

def main():
    """This starts the Flask server on port 5000 """
    threading.Thread(target=run_mfix).start()
    time.sleep(1)

    if 0==mfix.compar.mype:
        app.run(host='0.0.0.0',debug=False)
    while(True): time.sleep(1)

# this only runs if the module was *not* imported
if __name__ == '__main__':
    main()
