#!/usr/bin/env python

import getopt
import json
import os
import sys
import threading
import time
import traceback

from flask import Flask, render_template, request, redirect, url_for

sys.path.append(os.getcwd())

import mfix

# The usual convention is to only use UPPERCASE for constants,
# However, Fortran modules are in uppercase since Fortran uses uppercase.
from mfix import compar as COMPAR
from mfix import iterate as ITERATE
from mfix import main as MAIN
from mfix import param1 as PARAM1
from mfix import run as RUN
from mfix import step as STEP

path = os.path.dirname(os.path.realpath(__file__))
app = Flask(__name__, static_folder=path+'/static', template_folder=path+'/templates')

requests = {}
responses = {}

mfix_stopped = True
pymfix_running = True

def run_mfix(keyword_args=[]):

    for arg in keyword_args:
        MAIN.add_command_line_argument(arg)

    MAIN.initialize()

    while pymfix_running:
        check_requests()

        global mfix_stopped
        if mfix_stopped or RUN.tstop <= RUN.time:
            time.sleep(0.1)
        else:
            do_step()

    MAIN.finalize()

def do_step():
    STEP.time_step_init()

    while True:
        ITERATE.iterate_init()
        while (ITERATE.nit<ITERATE.max_nit and not (ITERATE.converged or ITERATE.diverged)):
            ITERATE.nit = ITERATE.nit + 1
            ITERATE.do_iteration()
            check_requests()

        if (ITERATE.converged):
            if (RUN.dt==PARAM1.undefined and ITERATE.nit==1):
                continue
            ITERATE.log_converged()
        elif (ITERATE.diverged):
            ITERATE.log_diverged()
        else:
            ITERATE.post_iterate()

        if(not ITERATE.adjustdt()):
            break

    STEP.time_step_end()

def check_requests():
    if requests:
        # requests would only arrive at rank 0
        req_id,cmd_var_args = requests.popitem()
    else:
        # command is empty for rank>0
        req_id = None
        cmd_var_args = (None,None,None)

    json_cmd_var_args = json.dumps(cmd_var_args)

    # broadcast command from rank 0 to all ranks

    json_cmd_var_args = MAIN.do_mpi_bcast(json_cmd_var_args)

    command, varname, args = json.loads(json_cmd_var_args.tostring())

    if command:
        handle(req_id,command,varname,args)

def handle(req_id,command,var,args):
    global mfix_stopped

    cmd = command.split(' ')[0].lower().strip()

    print("THE COMMAND IS %s" % cmd)

    # TODO: refactor with a Command class, instead of a big switch statement
    if cmd=='write_dbg_vt':
        responses[req_id] = 200,'Calling WRITE_DBG_VTU_AND_VTP_FILES\n'
        MAIN.do_write_dbg_vtu_and_vtp_files()

    elif cmd=='backupres':
        responses[req_id] = 200,'BACKING UP RESOURCE FILES\n'
        MAIN.do_backupres()

    elif cmd=='reinit':
        responses[req_id] = 200,'REINITIALIZING MFIX\n'
        MAIN.do_reinit(args.get('filename',None))

    elif cmd=='exit':
        responses[req_id] = 200,'EXITING MFIX\n'
        global pymfix_running
        pymfix_running = False

    elif cmd=='abort':
        responses[req_id] = 200,'ABORTING MFIX\n'
        MAIN.do_abort()

    elif cmd=='stop':
        responses[req_id] = 200,'STOPPING MFIX\n'
        mfix_stopped = True

    elif cmd=='start':
        responses[req_id] = 200,'STARTING MFIX\n'
        mfix_stopped = False

    elif cmd=='step':
        stepcount = int(args.get('stepcount',None))
        for _ in range(stepcount):
            do_step()
        responses[req_id] = 200,'DOING %s TIMESTEP(S)\n' % stepcount

    elif cmd=='get':

        ids = args.get('ids',None)

        # slow things down for development
        time.sleep(COMPAR.mype)

        if var:
            if ids and len(ids.split(' ')) > 3:
                print("GOING TO GET IDS %s" % var)
                ii,jj,kk,i2,j2,k2 = command.split(' ')[3:9]
                for i in range(int(ii),int(i2)+1):
                    for j in range(int(jj),int(j2)+1):
                        for k in range(int(kk),int(k2)+1):
                            if is_on_mype_owns(i,j,k):
                                exec_string = ('%s[%d] = %s' % (var,funijk(i,j,k)))
                                print("GOING TO EXECUTE: %s" % exec_string)
                                exec(exec_string)
                                print("rank ",COMPAR.mype," set value for",i,j,k,funijk(i,j,k))
                            else:
                                print("rank ",COMPAR.mype,"does not own",i,j,k,funijk(i,j,k))
            else:
                print("GOING TO EVALUATE %s" % var)
                try:
                    val = str(eval(var))
                    responses[req_id] = 200,val
                except:
                    traceback.print_exc()
                    # TODO: use error code for REST call
                    val = "ERROR: could not evaluate "+var
                    responses[req_id] = 400,val

                print("GOING TO RETURN %s" % val)

    elif cmd=='set':

        val = args.get('varvalue',None)
        ids = args.get('ids',None)

        # slow things down for development
        time.sleep(COMPAR.mype)

        if var and val:
            if ids and len(ids.split(' ')) > 3:
                print("GOING TO SET IDS %s = %s" % (var,val))
                ii,jj,kk,i2,j2,k2 = command.split(' ')[3:9]
                for i in range(int(ii),int(i2)+1):
                    for j in range(int(jj),int(j2)+1):
                        for k in range(int(kk),int(k2)+1):
                            if is_on_mype_owns(i,j,k):
                                exec_string = ('%s[%d] = %s' % (var,funijk(i,j,k),val))
                                print("GOING TO EXECUTE: %s" % exec_string)
                                exec(exec_string)
                                print("rank ",COMPAR.mype," set value for",i,j,k,funijk(i,j,k))
                            else:
                                print("rank ",COMPAR.mype,"does not own",i,j,k,funijk(i,j,k))
            else:
                print("GOING TO SET %s = %s" % (var,val))
                try:
                    exec('%s = %s' % (var,val))
                    responses[req_id] = 200,'ok, I set %s to %s\n' % (var,val)
                except AttributeError:
                    # TODO: better error code REST response
                    responses[req_id] = 500,'ERROR could not set: %s to %s\n' % (var,val)

                print('ok, I set %s to %s\n' % (var,val))
        else:
            responses[req_id] = 500,'could not set %s to %s\n' % (var,val)
    else:
        responses[req_id] = 500,'UNRECOGNIZED COMMAND\n'

def funijk(i,j,k):
    return COMPAR.ijk_array_of[i,j,k]

def is_on_mype_owns(li, lj, lk):
      return li >= COMPAR.istart and li <= COMPAR.iend and lj >= COMPAR.jstart and lj <= COMPAR.jend and lk >= COMPAR.kstart and lk <= COMPAR.kend


# Route that will process the file upload
@app.route('/upload', methods=['POST'])
def upload():
    # Get the name of the uploaded file
    ff = request.files['file']
    if ff:
        # filename = ff.filename
        filename = 'mfix.dat.upload'
        ff.save(os.path.join(os.getcwd(), filename))
    else:
        filename = None
        data = None

    status_code, data = do_command( "REINIT", args={'filename':filename} )

    return redirect(url_for('index',
                            filename=filename))

@app.route('/')
def index():
    return render_template('index.html', mfixdat_filename = request.args.get('filename',''))

@app.route('/set/<varname>',methods=['POST'])
def set(varname):
    status_code, data = do_command( "SET", varname, args=request.form )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/get/<varname>',methods=['GET'])
def get(varname):
    status_code, data = do_command( "GET", varname, args=request.args )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/write_dbg_vt',methods=['POST'])
def write_dbg_vt():
    status_code, data = do_command( "WRITE_DBG_VT" )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/backupres',methods=['POST'])
def backupres():
    status_code, data = do_command( "BACKUPRES" )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/exit',methods=['POST'])
def exit():
    status_code, data = do_command( "EXIT" )
    time.sleep(1) # wait for MFIX thread to end
    os._exit(0)
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/abort',methods=['POST'])
def abort():
    status_code, data = do_command( "ABORT" )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/step',methods=['POST'])
def step():
    status_code, data = do_command( "STEP", args=request.form )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/start',methods=['PUT'])
def start():
    status_code, data = do_command( "START" )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

@app.route('/stop',methods=['PUT'])
def stop():
    status_code, data = do_command( "STOP" )
    return data, status_code, {'Content-Type': 'text/plain; charset=utf-8'}

def do_command(cmd, varname=None, args = []):
    req_id = threading.current_thread().ident
    requests[req_id] = ( cmd, varname, args )
    while req_id not in responses:
        time.sleep(0.1)
    resp = responses[req_id]
    del responses[req_id]

    return resp

def parse_command_line_arguments():
    port = 5000 # Flask default
    usage_string = "Usage: pymfix [-h,--help] [ -p,--port <port> ] [ -s,--start ] [<keyword>=<keywordvalue> ...]"
    try:
        opts, keyword_args = getopt.getopt(sys.argv[1:],"hsp:",["port=",])
    except getopt.GetoptError:
        print usage_string
        sys.exit(1)

    for opt, arg in opts:
        if opt in ("-h","--help"):
            print usage_string
            sys.exit(0)
        elif opt in ("-s","--start"):
            global mfix_stopped
            mfix_stopped = False
        elif opt in ("-p","--port"):
            port = arg
            try:
                port = int(port)
                if (port < 0 or 65536 < port): raise ValueError
            except ValueError:
                print "Invalid port: ",port
                sys.exit(1)

    if (len(keyword_args) > 100):
        print("Too many command line arguments: %d.  Only 100 or fewer command line arguments are supported." % len(keyword_args))
        sys.exit(1)

    return port, keyword_args

def main():
    """The main function starts MFIX on a separate thread, then start the Flask server. """

    port, keyword_args = parse_command_line_arguments()

    threading.Thread(target=run_mfix, kwargs={"keyword_args":keyword_args}).start()

    # wait for the MFIX thread to initialize COMPAR.mype
    time.sleep(0.1)

    # start the Flask server on rank 0
    if 0==COMPAR.mype:
        app.run(host='0.0.0.0', port=port, debug=False)
    else:
        # nothing else for rank>0 to do
        while True: time.sleep(10)

if __name__ == '__main__':
    main()
